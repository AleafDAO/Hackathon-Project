pragma solidity ^0.8.0;

contract EnglishAuction {
    struct AuctionItem {
        address payable seller; // 拍卖物品的卖家地址
        uint256 startingPrice; // 拍卖物品的起始价格
        uint16 depositPercentage; // 卖家需要缴纳的保证金比例
        bool exists; // 拍卖物品是否存在的标志
        uint256 currentHighestBid; // 当前最高出价
        address payable currentHighestBidder; // 当前最高出价者的地址
        bool ended; // 拍卖是否结束的标志
    }

    mapping(uint256 => AuctionItem) public auctions; // 存储拍卖物品的映射
    mapping(uint256 => mapping(address => uint256)) public bids; // 存储竞标记录的映射
    mapping(address => uint256) public pendingReturns; // 待退款列表
    uint256 public auctionId = 1; // 下一个拍卖物品的编号

    // 创建拍卖函数，需要提供起始价格和保证金比例，并支付相应的保证金
    function createAuction(uint256 _startingPrice, uint16 _depositPercentage) public payable {
        require(_depositPercentage >= 20 && _depositPercentage < 100, "Invalid deposit percentage"); // 保证金比例必须在20%到100%之间
        require(msg.value >= (_startingPrice * _depositPercentage / 100), "Insufficient deposit"); // 支付的保证金必须不低于起始价格乘以保证金比例

        auctionId++; // 增加拍卖编号
        auctions[auctionId] = AuctionItem({ // 创建拍卖物品结构体
            seller: payable(msg.sender), // 设置卖家地址
            startingPrice: _startingPrice, // 设置起始价格
            depositPercentage: _depositPercentage, // 设置保证金比例
            exists: true, // 设置拍卖物品存在标志为true
            currentHighestBid: 0, // 初始化当前最高出价为0
            currentHighestBidder: payable(address(0)), // 初始化当前最高出价者地址为空地址
            ended: false // 初始化拍卖未结束
        });
    }

    // 竞标函数，需要提供拍卖物品编号和出价金额
    function bid(uint256 _itemId, uint256 _bidAmount) public {
        require(auctions[_itemId].exists, "Auction does not exist"); // 拍卖物品必须存在
        require(!_auctionEnded(_itemId), "Auction already ended"); // 拍卖必须尚未结束
        require(_bidAmount > auctions[_itemId].currentHighestBid, "Bid amount must be higher than current highest bid"); // 出价金额必须高于当前最高出价

        if (auctions[_itemId].currentHighestBidder != address(0)) { // 如果当前最高出价者不是空地址
            pendingReturns[auctions[_itemId].currentHighestBidder] += auctions[_itemId].currentHighestBid; // 将之前最高出价者的出价加入待退款列表
        }
        
        auctions[_itemId].currentHighestBid = _bidAmount; // 更新当前最高出价
        auctions[_itemId].currentHighestBidder = payable(msg.sender); // 更新当前最高出价者地址为当前竞标者地址
    }

    // 结束拍卖函数，只有拍卖物品的卖家可调用
    function endAuction(uint256 _itemId) public {
        require(msg.sender == auctions[_itemId].seller, "Only the seller can end the auction"); // 只有卖家可以结束拍卖
        require(!_auctionEnded(_itemId), "Auction already ended"); // 拍卖必须尚未结束

        auctions[_itemId].ended = true; // 标记拍卖结束
        _finalizeAuction(_itemId); // 调用内部函数完成拍卖结算
    }

    // 内部函数：检查拍卖是否已结束
    function _auctionEnded(uint256 _itemId) internal view returns (bool) {
        return auctions[_itemId].ended;
    }

    // 内部函数：完成拍卖结算
    function _finalizeAuction(uint256 _itemId) internal {
        AuctionItem storage item = auctions[_itemId];
        require(item.ended, "Auction not ended yet");

        // 计算总金额
        uint256 totalAmount = item.currentHighestBid;
        // 计算平台手续费
        uint256 platformFee = totalAmount * 5 / 100;
        // 计算卖家应获得的金额（起拍价的20%）
        uint256 sellerRefund = item.startingPrice * 20 / 100;
        // 计算卖家最终应获得的金额（扣除平台手续费和起拍价的20%）
        uint256 sellerAmount = totalAmount - platformFee - sellerRefund;
        // 计算竞拍者最终应支付的金额（扣除平台手续费）
        uint256 winnerAmount = totalAmount - platformFee;

        // 将卖家起拍价的20%退还给卖家
        item.seller.transfer(sellerRefund);
        // 将剩余金额转给卖家
        item.seller.transfer(sellerAmount);
        // 将竞拍者应支付的金额记录到待退款列表中
        pendingReturns[item.currentHighestBidder] += winnerAmount;

        // 将平台手续费按照3%分给竞拍者，2%归平台
        uint256 bidderFee = totalAmount * 3 / 100;
        uint256 platformReward = totalAmount * 2 / 100;
        uint256 bidAmount = item.currentHighestBid;
        uint256 bidderReward = (bidAmount * bidderFee) / totalAmount;
        uint256 platformReward = bidderFee - bidderReward;
        pendingReturns[item.currentHighestBidder] += bidderReward;
        // 将2%的手续费转给平台地址
        address platformAddress = /* platform address */;
        platformAddress.transfer(platformReward);
    }


}
目前的审计进度
1.`transfer` 函数只能被 `address payable` 类型的对象调用，而 `auctions[_itemId].currentHighestBidder` 的类型是 `address`，不是 `address payable`。要解决这个问题，需要将 `currentHighestBidder` 的类型更改为 `address payable`
   （已经改正，可以看看）
2.这里uint256 totalAmount = item.currentHighestBid;
还有    uint256 bidAmount = item.currentHighestBid;
        uint256 bidderReward = (bidAmount * bidderFee) / totalAmount;
        uint256 platformReward = bidderFee - bidderReward;
bidderReward = (bidAmount * bidderFee) / totalAmount;  导致了结果为bidderfee，，那么后面的 platformReward为0了
    （未修改）
3.  function cancelAuction(uint256 _itemId) public {
        AuctionItem storage item = auctions[_itemId];
        require(msg.sender == item.seller, "Only seller can cancel the auction"); // 只有卖家可以取消拍卖
        require(!item.ended, "Auction already ended"); // 拍卖必须尚未结束

        uint256 totalAmount = item.startingPrice;
        uint256 maxBid = item.currentHighestBid;
        uint256 maxBidderReward = totalAmount * 40 / 100; // 最大出价者奖励40%
        uint256 remainingAmount = totalAmount - maxBid;
        uint256 remainingBidderRewardPool = (totalAmount * 20 / 100) * 40 / 100; // 剩余出价者奖励40%
        uint256 platformReward = (totalAmount * 20 / 100) * 20 / 100; // 平台奖励20%

        // 将最大出价者奖励40%存入待退款映射中
        pendingReturns[item.currentHighestBidder] += maxBidderReward;

        // 遍历剩余出价者，按质押额比例分配40%的奖励
        for (uint i = 0; i < item.bidders.length; i++) {
            if (item.bidders[i] != item.currentHighestBidder) {
                uint256 bidAmount = item.bidAmounts[item.bidders[i]];
                uint256 bidderReward = (bidAmount * remainingBidderRewardPool) / totalAmount;
                pendingReturns[item.bidders[i]] += bidderReward;
            }
        }
这里startingPrice是起拍价而不是质押价格，，totalAmount - maxBid;  这个结果是个负数
